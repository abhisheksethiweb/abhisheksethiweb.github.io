WEBVTT
Kind: captions
Language: zh-CN

00:00:03.060 --> 00:00:08.214
到目前为止 我们已经讨论了离散化连续状态空间的各种方式

00:00:08.214 --> 00:00:09.640
这些方式使我们能够几乎不做修改

00:00:09.640 --> 00:00:14.065
就能使用现有的强化学习算法

00:00:14.064 --> 00:00:16.149
但是也存在一些限制

00:00:16.149 --> 00:00:18.759
当底层空间很复杂时

00:00:18.760 --> 00:00:22.600
所需的离散状态数量可能会很大

00:00:22.600 --> 00:00:25.495
因此就失去了离散化的优势

00:00:25.495 --> 00:00:29.980
此外 对于状态空间里临近的位置

00:00:29.980 --> 00:00:34.015
它们的值应该相似或者平滑地变化

00:00:34.015 --> 00:00:37.582
但是离散化并非始终会利用这一特性

00:00:37.582 --> 00:00:41.030
无法跨空间地有效泛化

00:00:41.030 --> 00:00:45.620
我们要获得的是真实的状态值函数 vπ

00:00:45.619 --> 00:00:48.259
或动作值函数 qπ

00:00:48.259 --> 00:00:52.534
通常在整个空间内都比较平滑连续

00:00:52.534 --> 00:00:53.959
可以想象

00:00:53.960 --> 00:00:59.810
除了一些非常简单的问题之外 完全捕获这种特性几乎不可行

00:00:59.810 --> 00:01:02.554
我们的最佳希望是函数逼近

00:01:02.554 --> 00:01:07.819
依然是逼近结果 因为我们不知道真正的底层函数是什么

00:01:07.819 --> 00:01:11.419
定义此类函数逼近的一般方法是

00:01:11.420 --> 00:01:15.379
引入一个表示函数形状的参数向量 W

00:01:15.379 --> 00:01:17.750
我们的任务变成调整这个参数向量

00:01:17.750 --> 00:01:21.665
直到找到理想的逼近结果

00:01:21.665 --> 00:01:25.910
注意逼近函数可以将状态映射到其值

00:01:25.909 --> 00:01:29.359
或将状态动作对映射到相应的 q 值

00:01:29.359 --> 00:01:34.265
另一种形式是从一个状态映射到一堆不同的 q 值

00:01:34.265 --> 00:01:36.859
同时映射到每个动作

00:01:36.859 --> 00:01:40.700
这对 Q 学习来说尤其实用 稍后我们会讲解

00:01:40.700 --> 00:01:42.769
先来看看第一种情况

00:01:42.769 --> 00:01:45.334
逼近状态值函数

00:01:45.334 --> 00:01:50.149
中间的方框应该会完成处理流程

00:01:50.150 --> 00:01:52.100
将状态 S 和参数 W

00:01:52.099 --> 00:01:55.759
转换为标量值

00:01:55.760 --> 00:01:58.835
但是如何转换呢？

00:01:58.834 --> 00:02:02.134
首先我们需要确保有一个表示状态的向量

00:02:02.135 --> 00:02:06.740
你的状态可能已经是一个向量 这样的话 你不需要进行任何处理

00:02:06.739 --> 00:02:11.314
通常 我们将定义一个转换算法

00:02:11.314 --> 00:02:16.055
将任何给定状态 S 转换为特征向量 X(s) 这样也给我们带来了更多的灵活性

00:02:16.055 --> 00:02:19.145
因为我们不需要对原始状态值进行运算

00:02:19.145 --> 00:02:22.680
我们可以改为使用任何计算或推导的特征

00:02:22.680 --> 00:02:25.870
现在我们已经有了

00:02:25.870 --> 00:02:27.594
特征向量 X(s) 和参数向量 W

00:02:27.594 --> 00:02:29.995
我们想要获得一个标量值

00:02:29.995 --> 00:02:33.039
如果我们有两个向量并想要生成标量

00:02:33.039 --> 00:02:35.057
该怎么办？

00:02:35.057 --> 00:02:38.784
进行点积运算 没错 这是最简单的方式

00:02:38.784 --> 00:02:43.914
实际上 这和计算特征的线性组合一样

00:02:43.914 --> 00:02:48.294
将每个特征与相应的权重相乘 然后求和

00:02:48.294 --> 00:02:51.399
称之为线性函数逼近

00:02:51.400 --> 00:02:53.439
即我们尝试使用线性函数

00:02:53.439 --> 00:02:56.530
逼近底层值函数

