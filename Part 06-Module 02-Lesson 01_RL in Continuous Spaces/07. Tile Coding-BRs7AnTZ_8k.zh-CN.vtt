WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:02.654
如果你以前就了解状态空间

00:00:02.654 --> 00:00:06.160
那么可以手动地设计相应的离散化方案

00:00:06.160 --> 00:00:08.359
就像在换挡示例中一样

00:00:08.359 --> 00:00:11.445
我们知道油耗和速度之间的关系

00:00:11.445 --> 00:00:14.595
但是为了在随机环境中正常运转

00:00:14.595 --> 00:00:16.574
我们需要一个更通用的方法

00:00:16.574 --> 00:00:20.199
一种比较合适的方式是 Tile Coding

00:00:20.199 --> 00:00:24.989
这里的底层状态空间是连续的二维空间

00:00:24.989 --> 00:00:29.039
我们在该空间上方叠加多个网格或拼贴

00:00:29.039 --> 00:00:32.079
每层都稍微不对齐

00:00:32.079 --> 00:00:35.039
状态空间里的任何位置 S

00:00:35.039 --> 00:00:38.234
都可以粗略地通过它所激活的拼贴识别

00:00:38.234 --> 00:00:40.582
如果我们为每个拼贴分配一个位

00:00:40.582 --> 00:00:44.628
则可以将新离散化状态表示为位向量

00:00:44.628 --> 00:00:48.840
激活的位置为 1 其他位置为 0

00:00:48.840 --> 00:00:52.730
这种方法本身是一个非常高效的表示法

00:00:52.729 --> 00:00:57.390
但是精彩之处在于如何使用该方案计算状态值函数

00:00:57.390 --> 00:01:01.499
它由该状态的位向量和每个拼贴的权重定义

00:01:01.499 --> 00:01:06.890
而不是为每个状态 V(s) 存储单独的值

00:01:06.890 --> 00:01:12.025
Tile Coding 算法然后迭代地更新这些权重

00:01:12.025 --> 00:01:18.300
这样可以确保共享拼贴的临近位置也共享状态值的一些部分

00:01:18.299 --> 00:01:21.995
从而有效地使所学的值函数更加平缓

00:01:21.995 --> 00:01:24.519
Tile Coding 也具有一些缺点

00:01:24.519 --> 00:01:29.280
和简单的网格方法一样

00:01:29.280 --> 00:01:31.094
我们需要提前手动选择拼贴大小

00:01:31.094 --> 00:01:33.414
偏移量 拼贴数量等等

00:01:33.415 --> 00:01:37.405
一个更加灵活的方式是 Adaptive Tile Coding

00:01:37.405 --> 00:01:39.754
先从非常大的拼贴开始

00:01:39.754 --> 00:01:43.744
然后在合适时将每个拼贴一分为二

00:01:43.745 --> 00:01:45.650
如何判断何时该拆分呢？

00:01:45.650 --> 00:01:47.905
我们可以采用试探法

00:01:47.905 --> 00:01:51.200
也就是说 当我们意识到通过当前的表示法

00:01:51.200 --> 00:01:55.500
不再学到很多规律时 即值函数不再改变

00:01:55.500 --> 00:01:59.230
我们就需要拆分状态空间

00:01:59.230 --> 00:02:02.855
当我们达到拼贴数量上限或迭代上限时

00:02:02.855 --> 00:02:04.972
可以停止拆分

00:02:04.972 --> 00:02:07.570
为了判断应该拆分哪个拼贴

00:02:07.570 --> 00:02:12.509
我们需要确定哪个拼贴最有可能对值函数的影响最大

00:02:12.509 --> 00:02:17.264
为此 我们需要跟踪子拼贴以及它们的预测权重

00:02:17.264 --> 00:02:22.519
然后我们可以选择子拼贴之间权重差别最大的拼贴

00:02:22.520 --> 00:02:24.635
你还可以使用很多其他试探法

00:02:24.634 --> 00:02:27.484
不过 Adaptive Tile Coding 的主要优势是

00:02:27.485 --> 00:02:32.670
它不需要我们手动提前指定离散化方式

00:02:32.669 --> 00:02:37.149
最终得到一个基于空间复杂程度的状态空间的划分

