WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:01.620
顾名思义

00:00:01.620 --> 00:00:06.810
离散化就是将连续空间转换为离散空间

00:00:06.809 --> 00:00:09.959
还记得连续吸尘器环境吗？

00:00:09.960 --> 00:00:15.825
我们重新回到标识了离散位置的网格结构

00:00:15.824 --> 00:00:18.899
注意 我们并非强迫智能体

00:00:18.899 --> 00:00:21.704
必须位于这些位置的中心区域

00:00:21.704 --> 00:00:23.759
因为底层环境是连续的

00:00:23.760 --> 00:00:25.685
因此我们无法控制这一状况

00:00:25.684 --> 00:00:28.419
但是在我们的状态空间表示法中

00:00:28.420 --> 00:00:31.615
我们仅关心某些位置标识信息

00:00:31.614 --> 00:00:35.679
例如 无论机器人位于 (3.1, 2.4) 还是 (2.9,1.8)

00:00:35.679 --> 00:00:40.329
我们都可以四舍五入为 (3,2)

00:00:40.329 --> 00:00:44.214
没错 这么处理肯定会不太准确

00:00:44.215 --> 00:00:45.565
但是对于某些环境

00:00:45.564 --> 00:00:48.504
离散化状态空间效果很好

00:00:48.505 --> 00:00:53.320
使我们能够几乎不加修改就能使用现有的算法

00:00:53.320 --> 00:00:55.585
动作也可以离散化

00:00:55.585 --> 00:00:58.750
例如 角可以拆分为完整度数

00:00:58.750 --> 00:01:01.715
甚至按 90 度递增 如果合适的话

00:01:01.715 --> 00:01:05.549
现在假设这个离散化环境中有一些物体

00:01:05.549 --> 00:01:08.159
机器人需要绕过这些障碍物

00:01:08.159 --> 00:01:10.064
对于网格表示法

00:01:10.064 --> 00:01:15.075
我们只能标记存在物体的单元格 甚至稍微超出范围

00:01:15.075 --> 00:01:17.685
称之为占据网格

00:01:17.685 --> 00:01:21.585
但是我们的离散化方式可能会使智能体以为

00:01:21.584 --> 00:01:26.204
没有绕过这些障碍物以抵达目标位置的道路

00:01:26.204 --> 00:01:30.644
如果我们能够根据这些障碍物调整网格

00:01:30.644 --> 00:01:34.069
那么可以为智能体找到一条潜在的道路

00:01:34.069 --> 00:01:39.174
另一种方法是在需要时将网格拆分为更小的单元格

00:01:39.174 --> 00:01:41.079
依然是逼近结果

00:01:41.079 --> 00:01:46.134
但是可以让我们在需要的位置分配更多的状态表示

00:01:46.135 --> 00:01:49.690
这样比将整个状态空间拆分为更小的单元格合适

00:01:49.689 --> 00:01:51.969
拆分整个状态空间可能会增加状态的总数

00:01:51.969 --> 00:01:55.105
进而增加计算值函数所需的时间

00:01:55.105 --> 00:01:58.150
如果你熟悉二叉空间分割或四元树的话 理解起来就很简单

00:01:58.150 --> 00:02:01.525
其实这是完全相同的概念

00:02:01.525 --> 00:02:03.565
现在你可能会疑问

00:02:03.564 --> 00:02:07.884
这种离散化适合网格世界等空间领域

00:02:07.885 --> 00:02:10.585
但是其他状态空间呢？

00:02:10.585 --> 00:02:13.629
我们来看看汽车换挡这个不同领域的问题

00:02:13.629 --> 00:02:17.004
如今的大部分汽车都会自动换挡

00:02:17.004 --> 00:02:21.669
你可曾想过 汽车如何决定切换到哪一挡以及何时换挡

00:02:21.669 --> 00:02:24.819
这个图表简单地描述了对于一辆普通汽车

00:02:24.819 --> 00:02:28.134
油耗如何随着不同挡位速度的变化而变化

00:02:28.134 --> 00:02:32.049
假设状态仅包含车辆速度

00:02:32.050 --> 00:02:33.730
以及当前挡位

00:02:33.729 --> 00:02:37.569
奖励与油耗成反比

00:02:37.569 --> 00:02:41.664
智能体可以采取的动作包括换到更高挡位或更低挡位

00:02:41.664 --> 00:02:44.694
虽然速度是连续值

00:02:44.694 --> 00:02:47.169
但是可以离散化为不同的范围

00:02:47.169 --> 00:02:51.684
最佳划分方式是一个挡位对应一个速度范围

00:02:51.685 --> 00:02:55.134
注意这些范围可以具有不同的长度

00:02:55.134 --> 00:02:58.389
即离散化是不均匀的

00:02:58.389 --> 00:03:02.679
如果状态空间还有其他维度 例如油门位置

00:03:02.680 --> 00:03:06.200
那么它们也可以不均匀地细分

