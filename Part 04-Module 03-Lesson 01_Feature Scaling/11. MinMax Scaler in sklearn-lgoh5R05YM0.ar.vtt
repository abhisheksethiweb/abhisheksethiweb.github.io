WEBVTT
Kind: captions
Language: ar

00:00:00.480 --> 00:00:04.070
‫في مقطع الفيديو هذا سأشرح لكم كيفية تنفيذ مثال دالة MinMaxScaler الذي

00:00:04.070 --> 00:00:06.390
‫نفذناه يدويًا ولكن هذه المرة في SKLearn.

00:00:06.390 --> 00:00:08.960
‫إن دالة MinMaxScaler، كالعادة، هي أمر

00:00:08.960 --> 00:00:12.700
‫اكتشفته للمرة الأولى عند زيارتي لوثائق SKLearn باستخدام Google.

00:00:12.700 --> 00:00:15.620
‫فعندما أبحث في Google عن مثال أجد نتائج مشابهة لتلك.

00:00:15.620 --> 00:00:16.980
‫ثم أنقر فوق الرابط الأول.

00:00:16.980 --> 00:00:20.410
‫توجد العديد من الدالات التي توفرها لنا لغة Python

00:00:20.410 --> 00:00:21.300
‫للمعالجة المسبقة للبيانات.

00:00:22.360 --> 00:00:24.720
‫واليوم سنتناول دالة MinMaxScaler،

00:00:24.720 --> 00:00:27.850
‫وهي تقع تحت هذه الفقرة الخاصة بقياس السمات في نطاق ما.

00:00:27.850 --> 00:00:30.610
‫وهذه هي صفحة الوثائق التي فتحتها عندما اكتشفت

00:00:30.610 --> 00:00:32.960
‫المثال الذي سأعرضه لكم الآن،

00:00:32.960 --> 00:00:35.780
‫ولكي أسهل عليكم المتابعة بأقصى درجة ممكنة، أقترح

00:00:35.780 --> 00:00:39.780
‫أن تفتحوا هذه الصفحة في علامة تبويب موازية في متصفحكم.

00:00:39.780 --> 00:00:42.330
‫ولكنني سأشرح أيضًا كل خطوة أنتقل إليها،

00:00:42.330 --> 00:00:45.730
‫لأوضح لكم كيفية استخدام ذلك في مثال عملي.

00:00:45.730 --> 00:00:48.620
‫سأنتقل إلى النافذة الطرفية ثم أبدأ تشغيل مترجم Python.

00:00:48.620 --> 00:00:51.710
‫وأول ما سأحتاج إلى فعله بعد ذلك هو استيراد الوحدة النمطية.

00:00:51.710 --> 00:00:53.090
‫ما أحتاج إلى فعله في الخطوة التالية،

00:00:53.090 --> 00:00:55.960
‫وقد كان ذلك أحد الأمور التي مثلت صعوبة بالنسبة لي في المرة الأولى

00:00:55.960 --> 00:00:59.560
‫هو import numpy، لأنه كما لاحظتم حتى الآن،

00:00:59.560 --> 00:01:03.120
‫تتطلب العديد من دالات SKLearn مدخلات numpy.

00:01:03.120 --> 00:01:03.950
‫دعوني أعرض لكم ما أعنيه.

00:01:03.950 --> 00:01:06.760
‫سوف أستخدم البيانات الخاصة بالأوزان في هذا المثال، لذا

00:01:06.760 --> 00:01:09.200
‫سأقوم بإنشاء سمة تسمى weights،

00:01:09.200 --> 00:01:12.340
‫وفي الواقع، سأقوم بتحويل هذه السمة إلى صفيف numpy.

00:01:12.340 --> 00:01:15.240
‫وقد حصلت على هذه الطريقة من المثال الموجود في صفحة وثائق SKLearn

00:01:15.240 --> 00:01:15.860
‫التي عرضتها لكم.

00:01:15.860 --> 00:01:19.060
‫لذا فأنا نوعًا ما أتبع الخطوات التي وضعوها.

00:01:19.060 --> 00:01:20.970
‫ما سأقوم به الآن هو إنشاء بيانات الإدخال.

00:01:20.970 --> 00:01:22.790
‫وفي هذه الحالة، سأستخدم مثال الأوزان.

00:01:22.790 --> 00:01:25.380
‫وأحد الأمور التي كانت تمثل صعوبة واضطررت فعليًا إلى

00:01:25.380 --> 00:01:29.680
‫التعامل معها لفهمها، هي أن ما نحتاج إليه هو صفيف numpy.

00:01:29.680 --> 00:01:33.600
‫سيكون كل عنصر في صفيف numpy عبارة عن نقطة تدريب مختلفة،

00:01:33.600 --> 00:01:36.790
‫وكل عنصر ضمن نقطة التدريب هذه سيكون عبارة عن سمة.

00:01:36.790 --> 00:01:39.590
‫إذن في هذه الحالة، أنا مهتمة بسمة واحدة فقط، ألا وهي سمة weights،

00:01:39.590 --> 00:01:42.110
‫كما أن لدي ثلاث نقاط تدريب مختلفة تمثل الأشخاص الثلاثة المختلفين.

00:01:42.110 --> 00:01:44.430
‫وعندما أقوم بإدخال البيانات، ستبدو بهذا الشكل.

00:01:44.430 --> 00:01:49.130
‫لدي الآن إدخال بيانات الأوزان، أصبحت مستعدة لاستخدام scaler عليه.

00:01:49.130 --> 00:01:52.700
‫هذا هو scaler الذي قمت باستيراده من SKlearn.preprocessing.

00:01:52.700 --> 00:01:55.130
‫وأريد أن أقوم بإنشاء سمة جديدة تسمى rescaled،

00:01:55.130 --> 00:01:57.190
‫لنطلق عليها rescaled_weight.

00:01:57.190 --> 00:02:00.890
‫ولإنشاء rescaled_weight، ما سأقوم به هو استدعاء fit_transform إلى الأوزان.

00:02:00.890 --> 00:02:02.270
‫وهذا في الواقع يقوم بشيئين.

00:02:02.270 --> 00:02:04.330
‫الشيء الأول الذي يقوم به هو الملاءمة.

00:02:04.330 --> 00:02:08.930
‫فهو يقوم بأمور مثل إيجاد قيمة XMIN وقيمة XMAX، ثم يقوم التحويل

00:02:08.930 --> 00:02:14.500
‫بتطبيق الصيغة على كل العناصر الموجودة في مجموعة البيانات.

00:02:14.500 --> 00:02:16.580
‫فهو يقوم بشيئين في الوقت نفسه.

00:02:16.580 --> 00:02:18.280
‫وفي بعض الأحيان سترغبون في القيام بشيء واحد فقط.

00:02:18.280 --> 00:02:21.670
‫حسنًا، لقد أعددت الأمور بحيث يقع خطأ هنا.

00:02:21.670 --> 00:02:23.040
‫دعوني أريكم ما سيحدث.

00:02:23.040 --> 00:02:25.470
‫حسنًا. لدينا خطأ هنا يقول أن الدالة

00:02:25.470 --> 00:02:29.570
‫تتوقع قيم فواصل عائمة للإدخال ولكنها حصلت على أرقام صحيحة بدلاً من ذلك.

00:02:29.570 --> 00:02:32.400
‫والسبب وراء ذلك مرتبط بهذا السطر.

00:02:32.400 --> 00:02:35.310
‫تعد جميع هذه المدخلات أعدادًا صحيحة، ولكنها تتوقع أرقامًا بفاصلة عائمة،

00:02:35.310 --> 00:02:37.490
‫وإذا كنتم قد أمعنتم النظر جيدًا في الوثائق، في المثال،

00:02:37.490 --> 00:02:40.200
‫بينما كنت أقوم بذلك، فربما استنتجتم

00:02:40.200 --> 00:02:43.530
‫أن ذلك سيمثل مشكلة بالنسبة لنا فيما بعد.

00:02:43.530 --> 00:02:46.490
‫لذا سأحول هذه القيم إلى أرقام بفاصلة عائمة عن طريق وضع

00:02:46.490 --> 00:02:49.680
‫فاصلة عشرية بعد كل منها وسنجرب ذلك مرة أخرى.

00:02:49.680 --> 00:02:50.690
‫رائع. هذا يبدو أفضل بكثير.

00:02:50.690 --> 00:02:52.290
‫لنطبع ذلك الآن.

00:02:52.290 --> 00:02:54.280
‫وبهذا نحصل على السمة المحولة الجديدة.

00:02:54.280 --> 00:02:57.710
‫إذن لدينا هنا الرقم 0.417 وهو الذي قمنا بحسابه في المثال السابق.

00:02:57.710 --> 00:03:02.060
‫وكما ترون، فإن أصغر قيمة في القائمة لها قيمة إعادة قياس بمقدار صفر،

00:03:02.060 --> 00:03:05.100
‫وأكبر قيمة لها قيمة إعادة قياس بمقدار واحد.

00:03:05.100 --> 00:03:07.105
‫وإذا أمعنا النظر جيدًا في المعادلة،

00:03:07.105 --> 00:03:09.950
‫فسيتضح لنا على الفور أن ذلك سيكون صحيحًا دائمًا.

00:03:09.950 --> 00:03:14.030
‫إذن، هذا مثال على كيفية استخدام دالة MinMaxScaler في SKLearn للقيام بما

00:03:14.030 --> 00:03:17.680
‫نفذناه يدويًا في المثال السابق، ولكن في بضعة أسطر فقط.

