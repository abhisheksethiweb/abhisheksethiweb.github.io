WEBVTT
Kind: captions
Language: zh-CN

00:00:00.480 --> 00:00:04.070
在该视频中 我将向你展示如何执行 MinMaxScaler 示例 

00:00:04.070 --> 00:00:06.390
我们之前曾手动完成过 但这次是在 sklearn 中

00:00:06.390 --> 00:00:08.960
和以往一样 我第一次接触 MinMaxScaler 是在

00:00:08.960 --> 00:00:12.700
使用 Google 访问 sklearn 文档时看到的

00:00:12.700 --> 00:00:15.620
当我使用 Google 搜索某个示例时 我收获了这种算法

00:00:15.620 --> 00:00:16.980
我点击第一个链接

00:00:16.980 --> 00:00:20.410
Python 提供了很多用于预处理数据的

00:00:20.410 --> 00:00:21.300
函数

00:00:22.360 --> 00:00:24.720
今天 我们介绍 MinMaxScaler 以及

00:00:24.720 --> 00:00:27.850
将特征缩放到某个范围的这一段下的内容

00:00:27.850 --> 00:00:30.610
这是我想到很快要展示给你的该示例时

00:00:30.610 --> 00:00:32.960
打开的文档页面

00:00:32.960 --> 00:00:35.780
因此 为了尽量降低难度 

00:00:35.780 --> 00:00:39.780
我建议你在浏览器的并列选项卡中打开该页面

00:00:39.780 --> 00:00:42.330
但我还会在介绍各个步骤时进行讲解

00:00:42.330 --> 00:00:45.730
从而向你展示如何在实践中使用该算法

00:00:45.730 --> 00:00:48.620
我通过终端窗口打开该页面 并启动 Python 翻译器

00:00:48.620 --> 00:00:51.710
首先我需要导入该模块

00:00:51.710 --> 00:00:53.090
然后我需要做的事是导入 numpy

00:00:53.090 --> 00:00:55.960
因为到现在 你也注意到大量的 sklearn 函数需要 numpy 输入

00:00:55.960 --> 00:00:59.560
这个过程是我在第一次执行时

00:00:59.560 --> 00:01:03.120
让我感觉很棘手的工作之一

00:01:03.120 --> 00:01:03.950
接下来 我说一下我要表达的意思

00:01:03.950 --> 00:01:06.760
我将使用该示例中的体重数据 

00:01:06.760 --> 00:01:09.200
因此 我将创建名为体重的特征

00:01:09.200 --> 00:01:12.340
然后将其放到 numpy 数组中

00:01:12.340 --> 00:01:15.240
我也是刚从向你展示的 sklearn 文档页面上的示例中

00:01:15.240 --> 00:01:15.860
学会该步骤

00:01:15.860 --> 00:01:19.060
我根据它们给出的步骤进行操作

00:01:19.060 --> 00:01:20.970
现在我要做的就是生成输入数据

00:01:20.970 --> 00:01:22.790
在该案例中 我将使用体重示例

00:01:22.790 --> 00:01:25.380
有一件事比较棘手 我需要认真说一下

00:01:25.380 --> 00:01:29.680
那就是你其实需要的是 numpy 数组

00:01:29.680 --> 00:01:33.600
numpy 数组的每个元素都会成为不同的训练点

00:01:33.600 --> 00:01:36.790
然后 训练点中的每个元素都会成为特征

00:01:36.790 --> 00:01:39.590
因此在该案例中 我其实只对一个特征感兴趣 即体重特征

00:01:39.590 --> 00:01:42.110
然后对于三个不同的人 我拥有了三个不同的训练点

00:01:42.110 --> 00:01:44.430
当我输入我的数据时 它看起来是这样的

00:01:44.430 --> 00:01:49.130
拥有自己的体重数据输入后 我就准备好在该输入上使用缩放器

00:01:49.130 --> 00:01:52.700
这就是我从 sklearn.preprocessing 中导入的缩放器

00:01:52.700 --> 00:01:55.130
我希望拥有名称为重缩放的新特征

00:01:55.130 --> 00:01:57.190
我们将其称作 rescaled_weight

00:01:57.190 --> 00:02:00.890
为生成 rescaled_weight 我要做的是在体重上调用 fit_transform

00:02:00.890 --> 00:02:02.270
这样其实就做了两件事

00:02:02.270 --> 00:02:04.330
第一件事是调整

00:02:04.330 --> 00:02:08.930
它会执行像查找 x_min 和 x_max 的操作 然后转换操作

00:02:08.930 --> 00:02:14.500
其实是针对数据集中的所有元素应用该公式

00:02:14.500 --> 00:02:16.580
所以说这是同时执行两项操作

00:02:16.580 --> 00:02:18.280
有时你只希望执行其中一项操作

00:02:18.280 --> 00:02:21.670
现在 我其实已经在这里犯了一个错误

00:02:21.670 --> 00:02:23.040
我向你展示一下会出现什么情况

00:02:23.040 --> 00:02:25.470
好的 我们收到一条错误 显示它正在运行

00:02:25.470 --> 00:02:29.570
假定将浮点值作为输入 而其实收到的是整数

00:02:29.570 --> 00:02:32.400
出现错误的原因与此处的该行有关

00:02:32.400 --> 00:02:35.310
所有这些输入都是整数 但它需要的是浮点数

00:02:35.310 --> 00:02:37.490
如果你像我一样认真阅读了该文档

00:02:37.490 --> 00:02:40.200
也就是该示例 你可能会发现

00:02:40.200 --> 00:02:43.530
这对我们来说后患无穷

00:02:43.530 --> 00:02:46.490
因此 我将会在每个数后面输入一个小数点

00:02:46.490 --> 00:02:49.680
将整数转变为浮点数 然后重新尝试一下

00:02:49.680 --> 00:02:50.690
好的 这次好多了

00:02:50.690 --> 00:02:52.290
我现在把它打印出来

00:02:52.290 --> 00:02:54.280
这样就有了我们新转换的特征

00:02:54.280 --> 00:02:57.710
在上个示例中 我们计算得出 0.417

00:02:57.710 --> 00:03:02.060
你也会发现列表中最小值经重缩放的值为零

00:03:02.060 --> 00:03:05.100
最大值经重缩放的值为一

00:03:05.100 --> 00:03:07.105
而且如果你认真观察等式

00:03:07.105 --> 00:03:09.950
会立即发现这通常都是真的

00:03:09.950 --> 00:03:14.030
这是有关如何在 sklearn 中使用 MinMaxScaler 的示例

00:03:14.030 --> 00:03:17.680
只需数行代码即可完成我们在上个示例中手动完成的任务

