WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:03.314
我们讨论了策略迭代

00:00:03.314 --> 00:00:06.474
并且讨论了截断策略迭代

00:00:06.474 --> 00:00:09.509
即只对整个状态空间

00:00:09.509 --> 00:00:13.669
执行有限次数的策略评估步骤

00:00:13.669 --> 00:00:17.234
换句话说 我们将每个状态的估算值更新次数

00:00:17.234 --> 00:00:21.964
限定为一定的数量 然后再进行策略完善

00:00:21.964 --> 00:00:25.449
在本视频中 你将学习值迭代

00:00:25.449 --> 00:00:29.634
在循环一次后停止策略评估步骤

00:00:29.635 --> 00:00:31.330
真的就这么简单

00:00:31.329 --> 00:00:34.530
实际上 你可以简化底层代码

00:00:34.530 --> 00:00:38.804
我们将在本视频的剩余时间内得出简单形式

00:00:38.804 --> 00:00:40.905
我们写出每个评估和完善步骤

00:00:40.905 --> 00:00:44.670
对应的伪代码

00:00:44.670 --> 00:00:47.535
首先要注意的是

00:00:47.534 --> 00:00:51.269
我们可以整合这几行 避免冗余

00:00:51.270 --> 00:00:53.340
尤其是 可以将第一行的动作值

00:00:53.340 --> 00:00:57.140
代入第二行

00:00:57.140 --> 00:00:59.700
注意 这个策略完善步骤

00:00:59.700 --> 00:01:02.850
后面跟着另一个策略评估步骤

00:01:02.850 --> 00:01:06.210
策略 π′ 是策略 π 的新值

00:01:06.209 --> 00:01:09.899
然后用该值完成一次策略评估

00:01:09.900 --> 00:01:13.750
很快发现这里也有冗余

00:01:13.750 --> 00:01:15.840
我们不再更新 π′

00:01:15.840 --> 00:01:19.465
并立即将它设为策略 π 的新值

00:01:19.465 --> 00:01:25.890
而是直接在值函数中更新策略 π 的值

00:01:25.890 --> 00:01:29.609
接着 我们需要更仔细地研究这两个方程

00:01:29.609 --> 00:01:33.319
我们发现它俩几乎一样

00:01:33.319 --> 00:01:39.077
具体而言 求和之后的所有元素几乎一样

00:01:39.078 --> 00:01:41.954
但是这里的值除外

00:01:41.954 --> 00:01:43.590
实际上 我们可以整合这两行

00:01:43.590 --> 00:01:48.135
并生成效果一样的一行公式

00:01:48.135 --> 00:01:52.140
为此 我们首先需要注意

00:01:52.140 --> 00:01:56.105
π(s) 是某个比较复杂的表达式的所有动作的 ARG Max

00:01:56.105 --> 00:02:00.760
我们可以将这一大串看做动作 a 的函数

00:02:00.760 --> 00:02:04.315
然后 V(s) 使用相同的函数

00:02:04.314 --> 00:02:08.879
但是计算的是在 π(s) 的值

00:02:08.879 --> 00:02:14.032
如果 π(s) 设为 ARG Max 而 V(s) 设为 ARG Max 时计算出的函数值

00:02:14.032 --> 00:02:17.339
那么我们可以直接将 V(s) 设为该函数的最大值

00:02:17.340 --> 00:02:22.807
然后将这个代入我们的算法

00:02:22.807 --> 00:02:26.709
我们先对值函数进行初始猜测

00:02:26.710 --> 00:02:29.265
算法循环访问状态空间

00:02:29.264 --> 00:02:33.774
成功地应用更新规则以便更准确地猜测值函数

00:02:33.775 --> 00:02:38.780
每次更新后 我们都检查值函数逼近结果是否已收敛

00:02:38.780 --> 00:02:40.449
如果已收敛

00:02:40.449 --> 00:02:42.739
则停止算法的这一部分

00:02:42.740 --> 00:02:46.000
收敛后 需要完成最后一步

00:02:46.000 --> 00:02:49.719
才能获得对应于最终值函数的策略

00:02:49.719 --> 00:02:51.879
准备好后 请按照下个部分的说明操作

00:02:51.879 --> 00:02:55.000
自己实现该算法

